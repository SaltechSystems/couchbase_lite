import 'dart:async';

import 'package:couchbase_lite/couchbase_lite.dart';
import 'package:couchbase_lite_example/beer_sample_app.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

void main() => runApp(BeerSampleApp(AppMode.production));
//void main() => runApp(ExampleApp());

class ExampleApp extends StatefulWidget {
  @override
  _ExampleAppState createState() => _ExampleAppState();
}

class _ExampleAppState extends State<ExampleApp> {
  String _displayString = 'Initializing';
  late Database database;
  Replicator? replicator;
  late ListenerToken _listenerToken;

  @override
  void initState() {
    super.initState();
    initPlatformState();
  }

  Future<String> runExample() async {
    // Platform messages may fail, so we use a try/catch PlatformException.
    try {
      database = await Database.initWithName("gettingStarted");
    } on PlatformException {
      return "Error initializing database";
    }

    // Create a new document (i.e. a record) in the database.
    MutableDocument? mutableDoc =
        MutableDocument().setDouble("version", 2.0).setString("type", "SDK");

    // Save it to the database.
    try {
      await database.saveDocument(mutableDoc);
    } on PlatformException {
      return "Error saving document";
    }

    // Update a document.
    mutableDoc = (await database.document(mutableDoc.id!))
        ?.toMutable()
        .setString("language", "Dart");

    if (mutableDoc != null) {
      // Save it to the database.
      try {
        await database.saveDocument(mutableDoc);

        var document = await (database.document(mutableDoc.id!));

        // Log the document ID (generated by the database)
        // and properties
        print("Document ID :: ${document!.id}");
        print("Learning ${document.getString("language")}");
      } on PlatformException {
        return "Error saving document";
      }
    }

    // Create a query to fetch documents of type SDK.
    var query = QueryBuilder.select([SelectResult.all()])
        .from("gettingStarted")
        .where(Expression.property("type").equalTo(Expression.string("SDK")));

    // Run the query.
    try {
      var result = await query.execute();
      print("Number of rows :: ${result.allResults().length}");
    } on PlatformException {
      return "Error running the query";
    }

    // Note wss://10.0.2.2:4984/my-database is for the android simulator on your local machine's couchbase database
    // Create replicators to push and pull changes to and from the cloud.
    ReplicatorConfiguration config =
        ReplicatorConfiguration(database, "ws://10.0.2.2:4984/beer-sample");
    config.replicatorType = ReplicatorType.pushAndPull;
    config.continuous = true;

    // Add authentication.
    config.authenticator = BasicAuthenticator("foo", "bar");

    // Create replicator (make sure to add an instance or static variable named replicator)
    var replicator = Replicator(config);

    // Listen to replicator change events.
    _listenerToken = replicator.addChangeListener((ReplicatorChange event) {
      if (event.status.error != null) {
        print("Error: " + event.status.error!);
      }

      print(event.status.activity.toString());
    });

    // Start replication.
    await replicator.start();
    return "Database and Replicator Started";
  }

  // Platform messages are asynchronous, so we initialize in an async method.
  Future<void> initPlatformState() async {
    var result = await runExample();

    // If the widget was removed from the tree while the asynchronous platform
    // message was in flight, we want to discard the reply rather than calling
    // setState to update our non-existent appearance.
    if (!mounted) return;

    setState(() {
      _displayString = result;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Plugin example app'),
        ),
        body: Center(
          child: Text(_displayString),
        ),
      ),
    );
  }

  @override
  void dispose() async {
    await replicator?.removeChangeListener(_listenerToken);
    await replicator?.stop();
    await replicator?.dispose();
    await database.close();

    super.dispose();
  }
}
